# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Королев И.М.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

Опишите, какие знания и навыки вы получите в результате выполнения курсового проекта

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: ...
 3. Реализовать предикат проверки/поиска .... 
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

Опишите, как вы получили родословное дерево в формате GEDCOM, сколько в нем индивидуумов.
Для получения родословного дерева в формате GEDCOM я воспользовался сайтом MyHeritage.com. В нём я построил своё родословное дерево с помощью его графического функционала. После построения родословного дерева в нём оказалось 76 персон.

## Конвертация родословного дерева

Опишите, какой язык/языки вы решили использовать для решения этой задачи и почему. Опишите принцип действия программы и приведите ключевые фрагменты 
программы, позволяющие понять основные моменты решения.

Для конвертации родословного дерева из формата GEDCOM в факты на языке Prolog был использован функционал языка Python. Этот язык удобен для парсинга.

В GEDCOM файле есть "уровни", каждый из которых обозначен числом. На уровне 0 можно узнать индекс нового человека для рассмотрения. На уровне 1 можно узнать имя и фамилию человека, его пол, номер семьи, в которой находятся его родители, номер семьи, которой находится он. После объявления всех участников дерева идёт информация о том, кто из участников явялется родителем для определённого ребёнка.

Программа проходит по файлу. Программа обрабатывает строки и в зависимости от написанного выполняет определённые действия. Если программа встретила строку с INDI, то она записывает индекс в массив. После этого она считывает имя человека в строке с NAME и записывает его в массив с именами. После того, как все участники дерева были объявлены создается база данных, в которой каждому индексу сопоставлено имя человека с этим индексом. После программа идёт дальше по файлу и находит родителей определённого ребёнка. Для этого она создаёт массив, в котором будут храниться данные об отце и матери каждого ребёнка. Если встретилась строка с HUSB, то человек с указанным в ней индексом является отцом. Если встретилась строка WIFE, то человек с указанным в ней индоксом является матерью. Если далее встетилась строка с CHIL, то человек с этим индексом является ребёнком найденных родителей. После нахождения всех родителей и детей, программа проходит по массиву родителей для каждого ребёнка и с помощью лямбда-выражения программа выписывает предикат parents(потомок, отец, мать) в файл facts.pl. 

```python 
def FindIndex(line): 
    Index = re.search(r"^0\s+@I(\d+)@\s+INDI$", line)        # Функция нахождения индекса
    if Index is not None:
        return Index.group(1)

def FindName(line):
    Name = re.search(r"^1\s+NAME\s+(.+)\s+/(.*)/$", line)      # Функция нахождения имени
    if Name is not None:
        if Name.group(2) == "":                                # Если нет фамилии, то возвращает только имя
            return Name.group(1)
        else:
            return Name.group(1) + " " + Name.group(2)         # Возвращает имя и фамилию
```

## Предикат поиска родственника

Опишите, как устроен предикат поиска родственника, приведите его исходный код и примеры запросов/ответов (протокол работы).

В варианте задания необходимо было найти всех троюродных братьев и сестёр. Для их нахождения небходимо знать двоюродных братьев и сестёр родителей. А для нахождения двоюродных братьев и сестёр родителей необходимо знать родных братьев и сестёр их родителей, то есть родных братьев и сестёр для бабушки и дедушки.

Был написан предикат нахождения родных братьев и сестёр. Он проверяет, что у двух людей одни и те же родители, а также эти два человека не являются одним и тем же человеком.

```prolog
sibliding(X, Y) :- parents(X, Parent1, Parent2), parents(Y, Parent1, Parent2), X\=Y.
```

Был написан предикат нахождения двоюродных братьев и сестёр. Он проверяет, что их родители являются родными братьями или сестрами, а также проверяет, что эти люди не являются одним и тем же человеком.
```prolog
double_sibliding(X, Y) :- parents(X, Parent11, _), parents(Y, Parent21, _), sibliding(Parent11, Parent21).
double_sibliding(X, Y) :- parents(X, Parent11, _), parents(Y, _, Parent22), sibliding(Parent11, Parent22).
double_sibliding(X, Y) :- parents(X, _, Parent12), parents(Y, Parent21, _), sibliding(Parent12, Parent21).
double_sibliding(X, Y) :- parents(X, _, Parent12), parents(Y, _, Parent22), sibliding(Parent12, Parent22).
```

Был написан предикат нахождения троюродных братьев и сестёр. Он проверяет, что их родители являются двоюродными братьями или сёстрами, а также проверяет, что эти люди не являются одним и тем же человеком.

```prolog
triple_sibliding(X, Y) :- parents(X, Parent11, _), parents(Y, Parent21, _), double_sibliding(Parent11, Parent21).
triple_sibliding(X, Y) :- parents(X, Parent11, _), parents(Y, _, Parent22), double_sibliding(Parent11, Parent22).
triple_sibliding(X, Y) :- parents(X, _, Parent12), parents(Y, Parent21, _), double_sibliding(Parent12, Parent21).
triple_sibliding(X, Y) :- parents(X, _, Parent12), parents(Y, _, Parent22), double_sibliding(Parent12, Parent22).
```

Результат работы:
```prolog
?- sibliding('Igor Korolew', X).
X = 'Marina Korolewa'.

?- double_sibliding('Igor Korolew', X). 
X = 'Dmitriy Korolew' ;
X = 'Natalia Korolewa' ;
X = 'Uriy Koriavets' ;
false.
      
?- triple_sibliding('Igor Korolew', X). 
X = 'Dmitriy Buzovkin' ;
X = 'Vladimir Maltzev' ;
X = 'Viktoriya Maltzeva' ;
X = 'Stanislav Maltzev' ;
X = 'Valeriya Maltzeva' ;
X = 'Polina' ;
X = 'Valeriya' ;
X = 'Ekaterina Korotkova' ;
X = 'Stanislav Durnev' ;
X = 'Anastasia Durneva' ;
X = 'Nikita Durnev' ;
false.
```

## Определение степени родства

Приведите описание метода решения, важные фрагменты исходного кода, протокол работы.

## Естественно-языковый интерфейс

## Выводы

Сформулируйте *содержательные* выводы по курсовому проекту в целом. Чему он вас научила? 
Над чем заставила задуматься? Помните, что несодержательные выводы -
самая частая причина снижения оценки.
