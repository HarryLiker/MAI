# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Королев И.М.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

В результате выполнения курсового проекта будут получены знания о том, как создать родословное дерево и экспортировать его в формате GEDCOM. Будут получены знания о том, как преобразовать данные из GEDCOM файла в факты на языке Prolog. Для этого будет написан парсер на языке Python, которые будет выполнять анализ строк и записывать преобразованные данные в файл с расширением Пролога. Будут получены знания о том, как на основе полученных фактов реализовать правила, с помощью которых можно будет решать необходимые задачи и находить ответы на поставленные запросы. Будут получены навыки написания предикатов для нахождения степи родства между двумя произвольными людьми из родословного дерева. Также будут получены знания о реализации естественно-языкового интерфейса на языке Prolog, который позволяет получать осмысленный ответ на поставленные запросы в виде предложений.
Опишите, какие знания и навыки вы получите в результате выполнения курсового проекта

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: с использованием предиката `parents(потомок, отец, мать)`.
 3. Реализовать предикат проверки/поиска троюродного брата или сестры. 
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

Для получения родословного дерева в формате GEDCOM я воспользовался сайтом MyHeritage.com. В нём я построил своё родословное дерево с помощью его графического функционала. После построения родословного дерева в нём оказалось 76 персон.

## Конвертация родословного дерева

Для конвертации родословного дерева из формата GEDCOM в факты на языке Prolog был использован функционал языка Python. Этот язык удобен для парсинга.

В GEDCOM файле есть "уровни", каждый из которых обозначен числом. На уровне 0 можно узнать индекс нового человека для рассмотрения. На уровне 1 можно узнать имя и фамилию человека, его пол, номер семьи, в которой находятся его родители, номер семьи, которой находится он. После объявления всех участников дерева идёт информация о том, кто из участников является родителем для определённого ребёнка.

Программа проходит по файлу. Программа обрабатывает строки и в зависимости от написанного выполняет определённые действия. Если программа встретила строку с INDI, то она записывает индекс в массив. После этого она считывает имя человека в строке с NAME и записывает его в массив с именами. После того, как все участники дерева были объявлены создается база данных, в которой каждому индексу сопоставлено имя человека с этим индексом. После программа идёт дальше по файлу и находит родителей определённого ребёнка. Для этого она создаёт массив, в котором будут храниться данные об отце и матери каждого ребёнка. Если встретилась строка с HUSB, то человек с указанным в ней индексом является отцом. Если встретилась строка WIFE, то человек с указанным в ней индексом является матерью. Если далее встретилась строка с CHIL, то человек с этим индексом является ребёнком найденных родителей. После нахождения всех родителей и детей, программа проходит по массиву родителей для каждого ребёнка и с помощью лямбда-выражения программа выписывает предикат parents(потомок, отец, мать) в файл facts.pl. 

```python 
def FindIndex(line): 
    Index = re.search(r"^0\s+@I(\d+)@\s+INDI$", line)        # Функция нахождения индекса
    if Index is not None:
        return Index.group(1)

def FindName(line):
    Name = re.search(r"^1\s+NAME\s+(.+)\s+/(.*)/$", line)      # Функция нахождения имени
    if Name is not None:
        if Name.group(2) == "":                                # Если нет фамилии, то возвращает только имя
            return Name.group(1)
        else:
            return Name.group(1) + " " + Name.group(2)         # Возвращает имя и фамилию
```

## Предикат поиска родственника

В варианте задания необходимо было найти всех троюродных братьев и сестёр. Для их нахождения необходимо знать двоюродных братьев и сестёр родителей. А для нахождения двоюродных братьев и сестёр родителей необходимо знать родных братьев и сестёр их родителей, то есть родных братьев и сестёр для бабушки и дедушки.

Был написан предикат нахождения родных братьев и сестёр. Он проверяет, что у двух людей одни и те же родители, а также эти два человека не являются одним и тем же человеком.

```prolog
% Проверка двух людей, на то что они являются родными братьями или сёстрами
sibling(X, Y) :- parents(X, Parent1, Parent2), parents(Y, Parent1, Parent2), X\=Y.
```

Был написан предикат нахождения двоюродных братьев и сестёр. Он проверяет, что их родители являются родными братьями или сестрами, а также проверяет, что эти люди не являются одним и тем же человеком.
```prolog
% Проверка двух людей, на то что они являются двоюродными братьями или сёстрами
double_sibling(X, Y) :- parents(X, Parent11, _), parents(Y, Parent21, _), sibling(Parent11, Parent21).
double_sibling(X, Y) :- parents(X, Parent11, _), parents(Y, _, Parent22), sibling(Parent11, Parent22).
double_sibling(X, Y) :- parents(X, _, Parent12), parents(Y, Parent21, _), sibling(Parent12, Parent21).
double_sibling(X, Y) :- parents(X, _, Parent12), parents(Y, _, Parent22), sibling(Parent12, Parent22).
```

Был написан предикат нахождения троюродных братьев и сестёр. Он проверяет, что их родители являются двоюродными братьями или сёстрами, а также проверяет, что эти люди не являются одним и тем же человеком.

```prolog
% Проверка двух людей, на то что они являются троюродными братьями или сёстрами
triple_sibling(X, Y) :- parents(X, Parent11, _), parents(Y, Parent21, _), double_sibling(Parent11, Parent21).
triple_sibling(X, Y) :- parents(X, Parent11, _), parents(Y, _, Parent22), double_sibling(Parent11, Parent22).
triple_sibling(X, Y) :- parents(X, _, Parent12), parents(Y, Parent21, _), double_sibling(Parent12, Parent21).
triple_sibling(X, Y) :- parents(X, _, Parent12), parents(Y, _, Parent22), double_sibling(Parent12, Parent22).
```

Результат работы:
```prolog
?- sibling('Igor Korolew', X).
X = 'Marina Korolewa'.

?- double_sibling('Igor Korolew', X).
X = 'Dmitriy Korolew' ;
X = 'Natalia Korolewa' ;
X = 'Uriy Koriavets' ;
false.
      
?- triple_sibling('Igor Korolew', X).
X = 'Dmitriy Buzovkin' ;
X = 'Vladimir Maltzev' ;
X = 'Viktoriya Maltzeva' ;
X = 'Stanislav Maltzev' ;
X = 'Valeriya Maltzeva' ;
X = 'Polina' ;
X = 'Valeriya' ;
X = 'Ekaterina Korotkova' ;
X = 'Stanislav Durnev' ;
X = 'Anastasia Durneva' ;
X = 'Nikita Durnev' ;
false.
```

## Определение степени родства

Для определения степени родства был использован поиск в ширину. Поиск в ширину удобен тем, что он рассматривает сразу множество возможных путей, постепенно увеличивая длину, пока не будет найден кратчайший путь между двумя людьми. Рассматривается очередь путей, которая изначально содержит путь из одной исходной вершины (человека, от которого мы должны найти путь ко второму). На каждом шаге берётся по одному пути из начала очереди и продлевается всеми возможными способами, после чего, результат помещается в конец очереди.

Были написаны предикаты нахождения прямых родственных связей (два человека связаны напрямую, а не через других родственников). Прямые родственные связи между людьми: ребёнок, отец, мать, брат/сестра (sibling), муж, жена.

```prolog
% Все родственники, которые прямо связаны друг с другом (не через других людей)
direct_relation(husband, Husband, Wife) :- parents(_, Husband, Wife).
direct_relation(wife, Wife, Husband) :- parents(_, Husband, Wife).
direct_relation(sibling, X, Y) :- sibling(X, Y).
direct_relation(father, Father, Child) :- parents(Child, Father, _).
direct_relation(mother, Mother, Child) :- parents(Child, _, Mother).
direct_relation(child, Child, Father) :- parents(Child, Father, _).
direct_relation(child, Child, Mother) :- parents(Child, _, Mother).
```

Для того, чтобы выполнять переход между двумя людьми, связанных напрямую, был написан предикат передвижения.

```prolog
% Переход между родственниками
move(X, Y) :- direct_relation(_, X, Y).
```

Поиск в ширину находит цепочку людей через которых связаны два заданных человека.
```prolog
% Предикат рекурсивного поиска в ширину
breadth([[Finish|T]|_], Finish, [Finish|T]).

% Продление первого пути в очереди всеми возможными способами
breadth([P|Q1], X, R) :- findall(Y, prolong(P, Y), T),
    append(Q1, T, Q2),
    breadth(Q2, X, R), !.

breadth([_|T], Y, L) :- breadth(T, Y, L).

% Предикат поиска пути в ширину. Находит путь, который состоит из людей, через которых связаны два человек.
breadth_search(Start, Finish, Path) :- breadth([[Start]], Finish, L), reverse(L, Path).
```

Предикат нахождения пути людей, через которых связаны два человека:
```prolog
% Находит путь по родственникам, через которых связаны два человека
relative_path(X, Y, Result) :- breadth_search(X, Y, Result).
```

После того, как был найден список людей, через которых связаны два человека, выполняется создание списка родственных связей между людьми. Выполняется проход этого списка слева направо и нахождение определенной прямой родственной связи между людьми.
 
 ```prolog
 % Предикат построения цепочки родства для родственников, находящихся в списке
conversation([_], []) :- !.
conversation([First,Second|Tail], ResultList) :- direct_relation(Relation, First, Second),
    ResultList = [Relation|PrevList],
    conversation([Second|Tail], PrevList), !.
```

Предикат нахождения цепочки родственных связей для двух произвольных людей из родословного дерева:

```prolog
% Предикат нахождения всего родственного пути для двух людей
relative(X, Y, Result) :- breadth_search(X, Y, PeopleChain), !, conversation(PeopleChain, Result).
```

Результаты работы:

```prolog
?- relative('Igor Korolew', 'Evgeniy Durnev', X).
X = [child, child, sibling, mother, wife].
?- relative_path('Igor Korolew', 'Evgeniy Durnev', X). 
X = ['Igor Korolew', 'Irina Vorontsova', 'Natalia Korotkova', 'Alla Korotkova', 'Olga Nikishina', 'Evgeniy Durnev'].

?- relative('Natalia Korolewa', 'Lidia Anozina', X).
X = [child, sibling, husband, child, child].
?- relative_path('Natalia Korolewa', 'Lidia Anozina', X). 
X = ['Natalia Korolewa', 'Sergey Korolew', 'Michail Korolew', 'Irina Vorontsova', 'Natalia Korotkova', 'Lidia Anozina'].

?- relative('Ivan Bobilev', 'Pavel Korolew', X).
X = [father, father, wife, child, child].
?- relative_path('Ivan Bobilev', 'Pavel Korolew', X).
X = ['Ivan Bobilev', 'Ilya Bobilev', 'Nadezda Bobileva', 'Anatoliy Korolew', 'Grigoriy Korolew', 'Pavel Korolew'].
```

Были выполнены два запроса для представления связей между двумя заданными людьми.

В первом примере был получен результат о том, что Igor Korolew является ребёнком ребёнка брата/жены матери жены Evgeniy Durnev. Из этого запроса и запроса пути, состоящего из людей, стало известно, что Igor Korolew является ребёнком для Irina Vorontsova, которая является ребёнком для Natalia Korotkova, которая является сестрой дял Alla Korotkova, которая является матерью для Olga Nikishina, которая является женой для Evgeniy Durnev.

Во втором примере был получен результат о том, что Natalia Korolewa является ребёнком ребёнка мужа ребёнка ребёнка Lidia Anozina. Из этого запроса и запроса пути, состоящего из людей, стало известно, что Natalia Korolewa является ребёнком для Sergey Korolew, который является братом для Michail Korolew, который является мужем для Irina Vorontsova, которая является ребёнком для Natalia Korotkova, которая является ребёнком для Lidia Anozina.

В третьем примере был получен результат о том, что Ivan Bobilev является отцом отца жены ребёнка ребёнка Pavel Korolew. Из этого запроса и запроса пути, состоящего из людей, стало известно, что Ivan Bobilev является отцом для Ilya Bobilev, который является отцом для Nadezda Bobileva, которая является женой для Anatoliy Korolew, который является ребёнком для Grigoriy Korolew, который является ребёнком для Pavel Korolew.

## Естественно-языковый интерфейс

Запросы задаваемые на естественно-языковом интерфейсе обрабатывают написанное предложение и находят результаты. Предложение состоит из разных частей, каждая от каждого из которых зависит результат запроса. Выполняется проверка на правильность заданного вопроса. Если вопрос правильный, то выполняется поиск ответа для него.

Были написаны предикаты, отвечающие за разбор части слова, т.е. к чему это слово относится.

```prolog
question_word(X) :- member(X, [who, how, "Who", "How"]).

% Количественное
count(X) :- member(X, [much, many]).

% Для того, чтобы в ответе написать правильное число
plurals(X) :- member(X, [child, children, sibling, siblings]).
plural(sibling, siblings).
plural(child, children).

% Вспомогательные слово
help_word(X) :- member(X, [do, does]).

have_has(X) :- member(X, [have, has]).

is(X) :- member(X, ["Is", is]).

s(X) :- member(X, ["'s"]).

question_mark(X) :- member(X, ['?']).
```

Для того, чтобы обрабатывать вопросы был написан предикат `question`. Предикат `find_relative` находит прямую связь между двумя людьми.
```prolog
 Нахождение, кто кем является по прямой связи
find_relative(X, Y, Result) :- which_relation(Result), !, direct_relation(Result, X, Y).

% How many _ does _ have?
question(List) :- List = [How, Many, C, Does, E, Have, G],
    question_word(How),
    count(Many),
    plurals(C),
    help_word(Does),
    have_has(Have),
    question_mark(G),
    plural(Y, C),
    setof(X, find_relative(X, E, Y), T),
    length(T, Result),
    write(E),
    write(" has "),
    ((Result =:= 1, write(Result), write(" "), write( Y)) ; 
    (not(Result =:= 1), write(Result), write(" "), write( C))), !.

% Who is _ _ ?
question(List) :- List = [Who, Is, C, S, E, F],
    question_word(Who),
    is(Is),
    s(S),
    which_relation(E),
    question_mark(F), !,
    direct_relation(E, Result, C),
    write(Result), write(" is "), write(C), write("'s "), write(E).
```

Результаты работы:
```prolog
?- question([how, many, children, does, 'Anatoliy Korolew', have, ?]).
Anatoliy Korolew has 3 children
true.

?- question([how, many, children, does, 'Elena Korolewa', have, ?]).   
Elena Korolewa has 1 child
true.

?- question([how, many, siblings, does, 'Michail Korolew', have, ?]).
Michail Korolew has 2 siblings
true.

?- question([who, is, 'Natalia Korolewa', "'s", father, ?]).
Sergey Korolew is Natalia Korolewa's father
true.

?- question([who, is, 'Natalia Korotkova', "'s", husband, ?]).
Sergey Sharkov is Natalia Korotkova's husband
true.
```

Из первого и второго примера видно, что программа выводит разное количество (children, child) в зависимости от количества найденных результатов.

## Выводы

Выполняя курсовую работу, я узнал как создавать собственное родословное дерево и конвертировать его в GEDCOM файл. Были получены навыки для реализации парсера. Написанный парсер может преобразовывать данные из GEDCOM файла в факты на языке Prolog. Так как парсер был написан на языке python, то были получены новые знания обработки файлов на этом языке. Были получены знания о том как с помощью имеющихся фактов писать правила, с помощью которых можно находить нужные решения. Были получены дополнительные навыки работы с поиском в ширину. Такой поиск для данной задачи является наиболее удобным. Он позволяет рассмотреть сразу все разветвления из вершины и найти кратчайший путь от одного человека ко второму через других людей. Также полы поучены знания для работы с естественно-языковым интерфейсом. С помощью него можно строить обычные предложения, которые представляют из себя запросы, на которые нужно получить ответ. Разбор предложений оказывается намного легче реализовать на языке Prolog, чем на других императивных языках программирования.
