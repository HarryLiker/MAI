# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Королев И. М.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |       4       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Списки в языке Пролог являются специальным видом терма, который представляется в виде последовательности элементов. В этом языке список может содержать в себе любые элементы, в то время как в императивных языках программирования списки хранят в себе элементы определённого типа. В языке Пролог список является рекурсивной структурой, он делится на голову и хвост. Для того, чтобы обратиться к элементу списка в императивных языках, нужно использовать итераторы. Если сравнивать список на Прологе со структурами данных в традиционных языках, то список очень похож на бинарное дерево, где левое поддерево - это элемент списка, а правое - это подсписок этого списка. Самый нижний правый элемент является пустым списком. При рекурсивном проходе списка в Прологе (справа налево) проход по дереву будет выполняться следующим образом: будет пройден правый элемент самого нижнего поддерева, потом левый, после чего происходит переход на уровень выше. То есть можно представить прохождение по этому дереву как ПЛК (правое - левое - корень).

## Задание 1.1: Предикат обработки списка

`change(V, N, List, NewList)` - заменяет все элементы списка List с указанным значением V на новые элементы со значением N.

Примеры использования:
```prolog
?- change(3, 7, [1,3,5,2,3,4], L).
L = [1, 7, 5, 2, 7, 4] .
?- change(1, 5, [2,3,4,6,4], L). 
L = [2, 3, 4, 6, 4] .
?- change(1, 8, [1,1,1,0], L).  
L = [8, 8, 8, 0] .
```

Реализация:
```prolog
change(_, _, [], []).
change(V, N, [Y|L], [Y|S]) :- Y\=V, change(V, N, L, S).
change(V, N, [V|L], [N|S]) :- change(V, N, L, S).
```

Выполняется проход по списку. Если следующий элемент по списку не является тем, который нужно заменить, то он просто добавляется к результирующему списку. Если следующий элемент по списку является тем, который нужно заменить, то в слева к результирующему списку добавляется новое изменённое значение.

Также предикат выполнения замены элементов в списке был реализован с помощью стандартного предиката append. Он копировал элементы в новый список, а потом работал с этим списком так же, как и в первом варианте.

Реализация:
```prolog
std_ch(V, N, List, NewList) :- append([], List, A), change(V, N, A, NewList).
```
Данная реализация не должна использовать первый вариант реализации предиката. Рекурсия д.б. заложена в стандартные предикаты.

## Задание 1.2: Предикат обработки числового списка

`exchange(List1, List2, List)` - разделяет список на два списка по порядковому принципу (первый - второй). 

Примеры использования:
```prolog
?- exchange(X, Y, [1,2,3,4,5,6,7,8]).
X = [1, 3, 5, 7],
Y = [2, 4, 6, 8] .
?- exchange(X, Y, [5,7,3,0,7]).
X = [5, 3, 7],
Y = [7, 0] .
?- exchange(X, Y, [1,2]).       
X = [1],
Y = [2] .
```

Реализация:
```prolog
% Разделение списка на два подсписка
separation([], 0, [], []).
separation([Y|X], N, [Y|A], B) :- separation(X, K, A, B), N is K+1, N mod 2 =:= 0.
separation([Y|X], N, A, [Y|B]) :- separation(X, K, A, B), N is K+1, N mod 2 =:= 1.

% Разделение списка на два подсписка по порядку элементов со стандартным предикатом без стандартных предикатов
exchange(List2, List1, List) :- separation(List, N, List1, List2), N mod 2 =:= 1.
exchange(List1, List2, List) :- separation(List, N, List1, List2), N mod 2 =:= 0.
```

Выполняется проход по списку справа налево и элементы записываются поочерёдно то в первый список, то во второй. При этом подсчитывается количество элементов в списке. Подсчёт нужен в том случае, если количество элементов оказалось чётное. В таком случае в первом списке окажутся все элементы по порядку 2, а во втором все элементы по порядку 1. И в результате списки меняются между собой, то есть первый теперь имеет элементы второго, а второй имеет элементы первого.

Также предикат разделения списков по порядковому принципу был реализован с помощью стандартного предиката length. Выполняются такие же действия по добавлению элементов в разные списки, после чего находится длина начального списка, и по этим данным списки либо меняются местами, либо остаются на своём месте.

Реализация:
```prolog
% Разделение списка на два подсписка
separation([], 0, [], []).
separation([Y|X], N, [Y|A], B) :- separation(X, K, A, B), N is K+1, N mod 2 =:= 0.
separation([Y|X], N, A, [Y|B]) :- separation(X, K, A, B), N is K+1, N mod 2 =:= 1.

% Разделение списка на два подсписка по порядку элементов со стандартным предикатом (Список 1, Список2, Начальный список)
standart_exchange(List2, List1, List) :- separation(List, _, List1, List2), length(List, K), K mod 2 =:= 1.
standart_exchange(List1, List2, List) :- separation(List, _, List1, List2), length(List, K), K mod 2 =:= 0.
```

## Задание 2: Реляционное представление данных

Реляционные базы данных - базы данных, которые строятся из таблиц. Благодаря реляционному представлению данных можно анализировать отношения между объектами. Такое представление помогает разбивать решение задачи на подзадачи, которые могут выполняться отдельно друг от друга.
Из минусов можно отметить, что при большом количестве правил, которые выражаются через другие, можно достаточно легко запутаться. Также при необходимости выделения определённых данных их дальнейшая сборка может оказаться непростой, так как не все данные легко отделить от остальных. 
Представление, которое я использовал, выглядит как списки студентов с номером их группы и их оценками за экзамены. В таком представлении не очень удобно находить для каждой группы студентов с максимальным баллом, так как нужно найти студента, принадлежащему данной группе, создать список из его оценок, посчитать его средний балл, сравнить его с другими средними баллами его одногруппиков. Если бы информация о студентах в группе, оценках студента, и предметах была бы разделена, то наверное, было бы удобнее. Но в моём случае легко узнать оценку студента за определённый предмет.  

## Задание 2.1: Для каждого студента, найти средний балл, и сдал ли он экзамены или нет

`sr_and_passed(Stud, Mark, P)` - выводит средний балл студента за предметы и сдал ли он экзамены.

Примеры использования:
```prolog
?- sr_and_passed('Петров', Mark, Pass).
Mark = 4 .
Pass = 'Все экзамены сданы'.
?- ?- sr_and_passed('Азурин', Mark, Pass).
Mark = 4.333333333333333 .
Pass = 'Экзамены не сданы' 
?- sr_and_passed('Круглотличников', Mark, Pass).  
Mark = 4 .
Pass = 'Все экзамены сданы'.
```

Реализация:
```prolog
% Оценки студента за предметы
grades(Stud, List) :- findall(M, mark_for_subj(Stud, _, M), List).

% Сумма оценок
summ_of_grades([], 0).
summ_of_grades([grade(_, Grade)|L], M) :- summ_of_grades(L, K), M is Grade + K.

% Средний балл студента
average_mark(Stud, Mark) :- student(_, Stud, List), summ_of_grades(List, Sum), length(List, Len), Mark is Sum / Len.

% Проверка на сдачу всех экзаменов
pass(Stud, P) :- grades(Stud, List), member(2, List), P is 1.
pass(Stud, P) :- grades(Stud, List), not(member(2, List)), P is 0.

% Вывод сообщения о сдаче / несдаче экзамена
print_pass(0, 'Все экзамены сданы').
print_pass(1, 'Экзамены не сданы').

% Средний балл студента и сдал ли он экзамены
sr_and_passed(Stud, Mark, P) :- average_mark(Stud, Mark), pass(Stud, K), print_pass(K, P).
```
Получает средний балл для студента за все предметы, выполняет проверку на сдачу всех экзаменов и возвращает средний балл и сообщение о сдаче экзаменов.

## Задание 2.2: Для каждого предмета, найти количество не сдавших студентов

`number_not_passed(Subj, Number)` - выводит количество студентов, которые не сдали экзамен по заданному предмету.

Примеры использования:
```prolog
?- number_not_passed('PSY', Number).
Number = 3 .
?- number_not_passed('LP', Number).  
Number = 0 .
?- number_not_passed('INF', Number). 
Number = 3 .
```

Реализация:
```prolog
% Оценка студента за предмет
mark_for_subj(Stud, Subj, X) :- student(_, Stud, List), member(grade(Subj, X), List).

% Счётчик вхождения элемента в список
counter([], _, 0).
counter([X|List], X, N) :- counter(List, X, K), N is K+1.
counter([Y|List], X, N) :- X\=Y, counter(List, X, N).

% Нахождение количества учеников, которые не сдали предмет
number_not_passed(Subj, Number) :- findall(X, mark_for_subj(_, Subj, X), List), counter(List, 2, Number).
```
Создает список всех оценок, полученных студентами за данный предмет. Счётчик проходит по списку, и, если встречается оценка 2 в списке, то он добавляет к N единицу. В конце выполнения счётчика будет получено количество всех студентов, которые не сдали экзамен.

## Задание 2.3: Для каждой группы, найти студента (студентов) с максимальным средним баллом

`max_average_student(Group, Stud)` - выводит студента (студентов), который имеет наивысший средний балл по предметам в своей группе.

Примеры использования:
```prolog
?- max_average_student(101, Student).
Student = 'Безумников' ;
Student = 'Густобуквенникова' ;
false.
?- max_average_student(103, Student). 
Student = 'Вебсервисов' ;
false.
?- max_average_student(104, Stud). 
Stud = 'Фулл' ;
false.
```

Реализация:
```prolog
% Максимальная оценка в списке
max([M],M).
max([M,T|L],Min) :- M=<T, max([T|L],Min).
max([M,T|L],Min) :- M>T, max([M|L],Min).

% Средние баллы студентов в группе
average_mark_in_gr(Group, Mark) :- student(Group, Stud, _), average_mark(Stud, Mark).

% Максимальная средняя оценка в группе
maximal_group_average_mark(Group, Mark) :- bagof(Mark, average_mark_in_gr(Group, Mark), List), max(List, Mark).

% Нахождение студента с наивысшим средним баллом
max_average_student(Group, Stud) :- student(Group, Stud, _), average_mark(Stud, AverMark), maximal_group_average_mark(Group, MaxMark), AverMark = MaxMark.
```
Находит студента, который принадлежит данной группе, находит его средний балл за экзамены, находит максимальный средний балл в группе и сравнивает, является ли найденный средний балл студента за экзамены максимальным. Если он является максимальным, то выводится имя студента.

## Выводы

При выполнении лабораторной работы №1 были получены навыки работы со списками, стандартными предикатами и их реализации. Были получены навыки выделения нужных данных и их обработки. Работа над лабораторной работой помогла лучше понять как в языке Пролог разделять большую задачу на подзадачи и какие могут быть варианты решения этой задачи. Программирование на языке Пролог действительно требует хороших логических рассуждений. Не имея этого навыка достаточно трудно составлять правила. Также достаточно трудно составлять правила, содержащие в себе много других правил так, чтобы они выполнялись верно. Пока что у меня не очень хорошо развиты логические рассуждения, поэтому нужно больше работать с этим языком для получения новых навыков. 
