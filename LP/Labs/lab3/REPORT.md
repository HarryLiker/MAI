#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Королев И.М.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |        4      |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Задачи, которые представляются в виде структуры состояний, которые могут быть представлены в виде последовательности действий, набора ситуаций удобным образом решаются методом поиска в пространстве состояний. Задачи, в которых есть начальное и конечное состояние удобно решать методом поиска в пространстве состояний. В таких задачах число всех возможных состояний должно быть конечным. Такое множество состояний можно представить как граф с вершинами в виде состояний. Сам путь от начальной вершины до конечной в таком графе будет представлять собой набор состояний, который будет являться решением задачи.

Пролог является удобным языком для решения задач методом поиска в пространстве состояний. На этом языке граф будет представлен в виде предикатов или правил, которые перечисляют дуги и вершины самого графа. Такое представление графа является более удобным, чем матричное представление в других языках программирования. При больших графах (с большим количеством дуг и вершин) матричное представление является неэффективным. А на языке Пролог, так как графы не представлены в виде матриц смежности, а при помощи правил, то работа с большими графами является более удобной.

## Задание

7. Вдоль доски расположены лунки, в каждой из которых лежит чёрный или белый шар. Одним ходом можно менять местами два соседних шара. Добиться того, чтобы сначала шли белые шары, а за ними - чёрные. Решить задачу за наименьшее число ходов.

## Принцип решения

Принцип решения задачи состоит в том, что программа проходит по списку, перебирая 2 шара, и проверяет, стоят ли эти шары в правильной последовательности. Если последовательность этих шаров неверна, то они меняются местами. 

Для выполнения лабораторной работы я использовал 3 алгоритма поиска: 
* Поиск в глубину
* Поиск в ширину
* Поиск с итерационным углублением

Был написан предикат перехода между вершинами графа. Он описывает правила для передвижения шаров. 

```prolog 
% Все передвижения шаров, которые могут быть
move(A,B) :- append(Begin,[b,X|End],A), append(Begin,[X,b|End],B).
move(A,B) :- append(Begin,[X,b|End],A), append(Begin,[b,X|End],B).
move(A,B) :- append(Begin,[w,X|End],A), append(Begin,[X,w|End],B).
move(A,B) :- append(Begin,[X,w|End],A), append(Begin,[w,X|End],B).
```

Чтобы предотвратить зацикливание в графе, был написан предикат, который продлевает все пути.
```prolog
% Предикат продления пути с предотвращением петель
prolong([X|T], [Y,X|T]) :-
    move(X, Y),
    not(member(Y, [X|T])).
```

**Поиск в глубину**. При таком поиске на каждой развилке, программа идёт по первой. В случае неудачи происходит возвращение на шаг назад и рассматривается другое направление. При поиске в глубину находится не обязательно кратчайший путь.

Предикат `depth` является вспомогательным. Он нужен для продления пути до тех пор, пока не будет достигнута целевая вершина.  
```prolog
% Предикат рекурсивного поиска в глубину
depth([Finish|T], Finish, [Finish|T]).

depth(TPath, Finish, Path) :- prolong(TPath, NewPath), depth(NewPath, Finish, Path).

% Предикат выполнения поиска в глубину
depth_search(Start, Finish) :- 
    get_time(Begin),
    depth([Start], Finish, Path), 
    answer_print(Path), 
    get_time(End), nl,
    ResultTime is End - Begin,
    write('Search time is: '), write(ResultTime).
```

**Поиск в ширину**. При таком поиске используется алгоритм фронта волны. Выполняется продление текущего алгоритма всеми возможными способами. Берётся путь из очереди, продляется всеми возможными способами и помещается в конец очереди.

Использование предиката `findall` нужно для построения списка всех возможных некоторого пути.

```prolog 
% Предикат рекурсивного поика в ширину
breadth([[X|T]|_], X, [X|T]).

% Продление первого пути в очереди всеми возможными способами
breadth([P|Q1], X, R) :- findall(Y, prolong(P, Y), T),
    append(Q1, T, Q2), !,
    breadth(Q2, X, R).

breadth([_|T], Y, L) :- breadth(T, Y, L).

% Предикат выполнения поиска в ширину
breadth_search(Start, Finish) :- 
    get_time(Begin),
    breadth([[Start]], Finish, Path),
    answer_print(Path),
    get_time(End), nl,
    ResultTime is End - Begin,
    write('Search time is: '), write(ResultTime).
```

**Поиск с итерационным углублением**. При таком поиске не хранятся все пути в очереди. 
```prolog 
% Предикат подсчёта высоты глубины 
depth_id([Finish|T], Finish, [Finish|T], 0).

depth_id(Path, Finish, R, N) :- 
    N > 0,
    prolong(Path,NewPath),
    N1 is N-1,
    depth_id(NewPath,Finish,R,N1).


% Предикат, генерирующий глубину поиска от 1 и далее
int(1).
int(K) :- int(N), K is N+1.

iterative_search(Start, Finish, Path, DepthLimit) :- depth_id([Start], Finish, Path, DepthLimit).

% Рекурсивный поиск в глубину с итеративным заглублением
iterative_search(Start, Finish, Path) :- 
    int(Limit),
    iterative_search(Start, Finish, Path, Limit).

% Предикат выполнения поиска в глубину с итеративным углублением 
iterative_search(Start, Finish) :- 
    get_time(Begin),
    iterative_search(Start,Finish, Path), 
    answer_print(Path), 
    get_time(End), nl,
    ResultTime is End - Begin,
    write('Search time is: '), write(ResultTime).
```

## Результаты

```prolog
?- depth_search([b,w,w,b,b,w,b],[w,w,w,b,b,b,b]).                                          

[b,w,w,b,b,w,b] -> [w,b,w,b,b,w,b] 
[w,b,w,b,b,w,b] -> [w,w,b,b,b,w,b] 
[w,w,b,b,b,w,b] -> [w,w,b,b,w,b,b] 
[w,w,b,b,w,b,b] -> [w,w,b,w,b,b,b] 
[w,w,b,w,b,b,b] -> [w,w,w,b,b,b,b] 
Search time is: 0.00700688362121582
true .

?- breadth_search([b,w,w,b,b,w,b],[w,w,w,b,b,b,b]). 

[b,w,w,b,b,w,b] -> [w,b,w,b,b,w,b]
[w,b,w,b,b,w,b] -> [w,w,b,b,b,w,b]
[w,w,b,b,b,w,b] -> [w,w,b,b,w,b,b]
[w,w,b,b,w,b,b] -> [w,w,b,w,b,b,b]
[w,w,b,w,b,b,b] -> [w,w,w,b,b,b,b]
Search time is: 0.7602241039276123
true .

iterative_search([b,w,w,b,b,w,b],[w,w,w,b,b,b,b]). 

[b,w,w,b,b,w,b] -> [w,b,w,b,b,w,b]
[w,b,w,b,b,w,b] -> [w,w,b,b,b,w,b]
[w,w,b,b,b,w,b] -> [w,w,b,b,w,b,b]
[w,w,b,b,w,b,b] -> [w,w,b,w,b,b,b]
[w,w,b,w,b,b,b] -> [w,w,w,b,b,b,b]
Search time is: 0.010977983474731445
true .
```

| Алгоритм поиска |  Длина найденного первым пути   |  Время работы  |
|-----------------|---------------------------------|---------------|
| В глубину       |                6                | 0.00700688362121582 |
| В ширину        |                6                | 0.7602241039276123  |
| ID              |                6                | 0.010977983474731445 |

## Выводы

Выполняя лабораторную работу, были получены знания об основных алгоритмах поиска, навыки работы с ними. Основными алгоритмами поиска были: поиск в глубину, поиск в ширину, поиск с итерационным углублением. При выполнении тестов было выяснено, что для решения поставленной задачи самым эффективным алгоритмом является поиск в глубину. Но недостатком поиска в глубину является то, что при таком поиске находится не обязательно кратчайший путь. Поэтому, если бы был задан другой граф, то длина найденного первого пути могла бы отличаться. Поиск в ширину оказался самым медленным среди всех. 

Для разных задач подходят разные виды поиска. Для нахождения какого-либо пути решения задачи будет достаточно поиска в глубину. Также он подходит тогда, когда есть строгое ограничение по памяти. Для того, чтобы найти кратчайший путь, подойдёт поиск в ширину. Поиск с итерационным заглублением не сильно хуже, чем поиск в ширину. Он сохраняет положительные стороны поиска в глубину и поиска в ширину, а также избегает экспоненциальный сложности. 
