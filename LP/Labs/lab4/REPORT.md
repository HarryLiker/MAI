#№ Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Королев И.М.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |      3        |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Для обработки естественных и искусственных языков обычно применяют подходы:
* Символьный
* Статистический

Символьный подход осуществляет глубокий анализ лингвистических явлений и основывается на явном представлении знаний о языке с помощью правил и словарей. В системах, основанных на логике, символьная структура обычно представлена в форме логических высказываний.

Статистический подход в качестве первичного источника информации использует наблюдаемые данные. Он основывается на том, что наиболее часто встречаемые слова в тексте отражают его смысл и содержание. Поэтому в этом подходе подсчитываются количества вхождений слов в текст. Статистический подход обычно используется для распознавания речи, пополнения словарей, парсинга, изучении грамматики и т.д.

Язык Prolog является удобным для обработки естественных и искусственных языков. С помощью него можно не сложным путём находить данные по шаблону, поэтому этот язык подходит для обработки текстов. Также Пролог очень хорошо подходит для обработки языка символьным способом, так символьный подход основывается на логике и правилах, которые не сложным способом можно описать на этом языке. 


## Задание

4. Реализовать синтаксический анализатор арифметического выражения для перевода его в префиксную форму. В выражении допустимы операции +,-,*,/.

Запрос: ```?- calculate([5, '+', 2, '*', 3], X).```

Результат: X = [\'+\',5,\'*\',2,3]

## Принцип решения

Опишите своими словами принцип решения задачи, приведите важные фрагменты кода.

При выполнении программы арифметическое выражение будет читаться справа налево. Для преобразования выражения в префиксную запись, будут использованы стек, в который будут помещаться встреченные операции, и результирующий список, в который будут помещаться числа из выражения и операции, которые будут удаляться из стека.
При проходе по этому выражению, которое является списком, программа будет выполнять определённые действия при встрече нового элемента:
* Если элемент является числом, то он помещается в результирующий список.
* Если элемент выражения является операцией, и стек операций либо пустой, либо вершина стека является операцией меньшей по приоритету, чем приоритет элемента, то этот элемент помещается в вершину стека.
* Если элемент выражения является операцией, и вершина стека больше по приоритету, чем приоритет элемента, то в результирующий список помещается операция из стека. После этого элемент выражения сравнивается с новой вершиной. Это происходит до того момента, пока не встретится операция, которая не выше по приоритету, чем у элемента. В конце выполнения этого алгоритма, элемент, который сравнивался с вершиной стека, помещается в сам стек. 

Для сравнения операций, и добавления их в стек, были написаны отношения приоритетов этих операций:

```prolog 
% Заданный приоритет операций
not_priority([], '+').
not_priority([], '-').
not_priority([], '*').
not_priority([], '/').

not_priority('+', '*').
not_priority('+', '/').

not_priority('-', '*').
not_priority('-', '/').

priority('+', []).
priority('+', '+').
priority('+', '-').

priority('-', []).
priority('-', '+').
priority('-', '-').

priority('*', []).
priority('*', '+').
priority('*', '-').
priority('*', '*').
priority('*', '/').

priority('/', []).
priority('/', '+').
priority('/', '-').
priority('/', '/').
priority('/', '*').
```

Для того, чтобы определять чем является очередной элемент выражения (числом или операцией), был написан предикат проверки элемента на число.

```prolog 
% Проверка нового элемента на число или операцию
is_number(X) :- number(X).
```

Предикат сравнения элемента выражения, который является операцией, с вершиной стека необходим для того, чтобы программа понимала что делать дальше: добавить этот элемент к стеку или удалить все элементы из стека, которые выше приоритетом, до первого стречного с таким же приоритетом и добавить их к результирующему списку.

```prolog
% Предикат нахождения вершины списка
get_top([], []).
get_top([X|_], X).
```

Был написан предикат для удаления всех элементов (операций) из стека, приоритет которых больше, чем у указанного элемента. Проход по стеку будет выполняться справа налево, пока не встретится операция, приоритет которой не выше, чем у указанного элемента. В итоге все элементы, которые слева от найденной операции удаляются из списка.

```prolog
% Удаление всех элементов из стека, которые выше по приоритету, чем заданная операция, до первого встречного элемента с таким же приоритетом.
% В итоге все эти элементы удалятся и результатом будет изменённый стек
delete_sequence(_,[],[]) :- !.

delete_sequence('*', _, []) :- !.
delete_sequence('/', _, []) :- !.

delete_sequence('-', [X|List],Result) :- (X = '-'; X = '+'), Result = [X|List], !.
delete_sequence('-', [X|List], Result) :- X\='-', X\='+', delete_sequence('-', List, Result), !.

delete_sequence('+', [X|List], Result) :- (X='-'; X='+'), Result = [X|List], !.
delete_sequence('+', [X|List], Result) :- X\='-', X\='+', delete_sequence('+', List, Result), !.
```

Был написан предикат для сохранения элементов стека, которые выше приоритетом, чем указанный элемент. Проход по стеку выполняется справа налево, пока не встретится операция, приоритет которой не выше, чем у указанного элемента. В итоге все элементы, которые были выше по приоритету записываются в новый список. Этот список понадобится для того, чтобы присоединить найденные операции к результирующему списку.

```prolog
% Нахождение элементов стека, которые выше по приоритету, чем заданная операция, до первого встречного с таким же приоритетом и запись их в отдельный список
save(_, [], []) :- !.

save('*', _, []) :- !.
save('/', _, []) :- !. 

save('-', [X|_], []) :- (X='+'; X='-'), !.
save('-', [X|Stack], [X|List]) :- not_priority('-', X), save('-', Stack, List), !.

save('+', [X|_], []) :- (X='+'; X='-'), !.
save('+', [X|Stack], [X|List]) :- not_priority('+', X), save('+', Stack, List), !.
```

Был написан предикат для прохождения по списку. Он выполняет все написанные выше предикаты. Если очередной элемент - число, то он добавляется к результирующему списку. Если очередной элемент - операция, и она выше по приоритету, чем операция на вершине стека, то она добавляется в вершину стека. Если эта операция ниже, то все первые операции из стека, которые выше по приоритету, добавляются в результирующий список, а эта операция добавляется в изменённый стек.

```prolog
% Если элемент - число, то добавляем его в список
expression_walk(Expression, Stack, List) :- append([X], PrevExpression, Expression), 
    append([X], PrevList, List), 
    is_number(X), 
    expression_walk(PrevExpression, Stack, PrevList), !.

% Если приоритет новой операции выше, чем на вершине стека, то она добавляется в стек.
expression_walk(Expression, Stack, List) :- append([X], PrevExpression, Expression), 
    append([X], PrevStack, Stack),
    not(is_number(X)), 
    get_top(PrevStack, Y),
    priority(X, Y), 
    expression_walk(PrevExpression, PrevStack, List), !.


% Если приоритет новой операции ниже или равен, чем на вершине стека, то все первые элементы, которые выше по приоритету, чем указанная операция, с вершины стека помещаются в список, а эта новая операция добавляется в стек.
expression_walk(Expression, Stack, List) :- append([X], PrevExpression, Expression), 
    append([X], NStack, Stack), 
    append(Result, PrevList, List), 
    not(is_number(X)),   
    get_top(LastStack, Y), 
    not_priority(X,Y),
    expression_walk(PrevExpression, LastStack, PrevList), 
    delete_sequence(X, LastStack, NStack), 
    save(X, LastStack, AddInList), 
    reverse(AddInList, Result), !.
 ```
 
Предикат перевода в префиксную форму выполняет проход по выражению, написанный выше, и добавляет оставшиеся элементы из стека к результирующему списку. В итоге получается префиксная форма выражения.

```prolog
calculate(Expression, X) :- expression_walk(Expression, Stack, List), 
    reverse(Stack, NewStack), 
    append(NewStack, List, X), !.
```

## Результаты

Приведены сравнения работы предиката ```calculate``` и перевода выражения в префикную форму самим языком Пролог.

```prolog
calculate([5,'+',2,'*',3], X).
X = [+, 5, *, 2, 3].

?- X = 5 + 2 * 3, display(X).
+(5,*(2,3))
X = 5+2*3.

?- X = 5 + 3 * 6 / 7 - 3 - 2, display(X).
-(-(+(5,/(*(3,6),7)),3),2)
X = 5+3*6/7-3-2.

?- calculate([5,'+',3,'*',6,'/',7,'-',3,'-',2], X). 
X = [-,-,+,5,/,*,3,6,7,3,2]

?- calculate([1,'-',3,'+',8,'/',2,'*',6], X). 
X = [+, -, 1, 3, *, /, 8, 2, 6].

?- X = 1 - 3 + 8 / 2 * 6, display(X).
+(-(1,3),*(/(8,2),6))
X = 1-3+8/2*6.   
```

## Выводы

Во время выполнения лабораторной работы я узнал как можно анализировать текст по символам. Моя программа проходит по арифметическому выражению справа налево, обрабатывает его элементы, и в зависимости от типа данного элемента выполняет указанные преобразования. Были получены навыки написания логики предикатов для выполнения преобразования арифметического выражения в префиксную форму. Я получил представления о том, как устроен синтаксический анализатор текста. При выполнении лабораторной работы мне стало интересно как реализовывать анализ текста по словам.

Язык Пролог является достаточно удобным для грамматического разбора. С помощью фактов и правил можно достаточно легко написать программу, которая с помощью них может анализировать текст и выполнять поставленную задачу. Язык Пролог имеет встроенные средства для работы с грамматикой, что тоже упращает анализ текста. Также Пролог является очень удобным при посимвольном анализе. Он позволяет проходить по каждому символу текста и преобразовывать его при встрече нужного символа.
